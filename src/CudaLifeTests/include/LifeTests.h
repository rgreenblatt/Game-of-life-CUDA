#pragma once

#include <gtest/gtest.h>

namespace mf {

	/// Helper (static) class to test life algorithms.
	template<typename NoCppFileNeeded = int>
	class TLifeTests {

	public:
		/// Checks a lookup table that evaluates 6x3 chunk of life world to 4x1 result.
		/// Table has to have 2^18 entries.
		static void checkLookupTable(const uint8_t* table) {
			// 6 x 3 helper array.
			bool cellStates[6 * 3];

			for (size_t key = 0; key < 1 << 18; ++key) {
				for (size_t i = 0; i < 6 * 3; ++i) {
					cellStates[i] = ((key << i) & 0x20000) != 0;
				}

				size_t expectedTableValue = 0;
				for (size_t t = 0; t < 4; ++t) {
					size_t aliveCount = 0;

					for (size_t dy = 0; dy < 3; ++dy) {
						for (size_t dx = 0; dx < 3; ++dx) {
							aliveCount += cellStates[dy * 6 + dx + t] ? 1 : 0;
						}
					}

					bool centerState = cellStates[1 * 6 + 1 + t];
					aliveCount -= centerState ? 1 : 0;

					expectedTableValue <<= 1;
					if (aliveCount == 3 || (aliveCount == 2 && centerState)) {
						expectedTableValue |= 1;
					}
				}

				if (uint8_t(expectedTableValue) != table[key]) {
					std::cout << "Evaluation table on index " << key << " representing state:" << std::endl;
					for (size_t row = 0; row < 3; ++row) {
						for (size_t col = 0; col < 6; ++col) {
							std::cout << (cellStates[row * 6 + col] ? "#" : ".");
						}
						std::cout << std::endl;
					}
					std::cout << "Expected to evaluate to:" << std::endl;
					for (size_t col = 0; col < 4; ++col) {
						std::cout << (((expectedTableValue << col) & 0x8) != 0 ? "#" : ".");
					}
					std::cout << std::endl << "Actual value:" << std::endl;
					for (size_t col = 0; col < 4; ++col) {
						std::cout << (((table[key] << col) & 0x8) != 0 ? "#" : ".");
					}
					std::cout << std::endl;
				}
				ASSERT_EQ(uint8_t(expectedTableValue), table[key]);
			}
		}

		/// Generates data of all combinations.
		/// Size of the data has to be 4 x 4 * 2^9 (/ 8 for bit-life).
		static void generateAllCombinationsData(uint8_t* data, bool bitLife) {

			// 4 rows, 4 * 2^9 columns.
			// 3 rows and 3 * 2^9 columns would be enough but I want to keep number of rows and columns powers of 2.
			size_t rowWidth = 4 * 1 << 9;
			size_t dataSize = 4 * rowWidth;

			uint8_t* resultData = data;
			if (bitLife) {
				// Generate data to temporary buffer and then convert them to bit-per-cell.
				resultData = new uint8_t[dataSize];
			}

			for (size_t combinationId = 0; combinationId < (1 << 9); ++combinationId) {
				size_t baseCol = combinationId * 3;
				size_t baseRow = 0;

				for (size_t row = 0; row < 3; ++row) {
					size_t r = baseRow + row;

					for (size_t col = 0; col < 3; ++col) {
						size_t c = baseCol + col;
						size_t index = row * 3 + col;
						uint8_t value = uint8_t((combinationId >> (8 - index)) & 0x1);
						resultData[r * rowWidth + c] = value;
					}
				}
			}

			if (bitLife) {
				std::memset(data, 0, dataSize / 8);
				for (size_t i = 0; i < dataSize; ++i) {
					data[i / 8] |= resultData[i] << (7 - (i % 8));
				}
			}
		}

		/// Checks cells of a world generated by generateAllCombinationsData function.
		/// Only checked cells are the ones in the middle of 3x3 areas. It does not matter how other cells are handled.
		static void checkAllCombinationsData(uint8_t* data, bool bitLife) {
			size_t rowWidth = 4 * 1 << 9;
			if (bitLife) {
				rowWidth /= 8;
			}

			for (size_t combinationId = 0; combinationId < (1 << 9); ++combinationId) {
				size_t baseCol = combinationId * 3 + 1;
				size_t baseRow = 1;

				bool expectedState = isMiddleAlive(combinationId);
				bool actualState;
				if (bitLife) {
					actualState = ((data[baseRow * rowWidth + (baseCol / 8)] >> (7 - (baseCol % 8))) & 0x1) != 0;
				}
				else {
					actualState = data[baseRow * rowWidth + baseCol] != 0;
				}

				if (expectedState != actualState) {
					std::cout << "Evaluation of life state " << combinationId << " represented as:" << std::endl;
					for (size_t row = 0; row < 3; ++row) {
						for (size_t col = 0; col < 3; ++col) {
							std::cout << (combinationId << (row * 3 + col) & 0x100 ? "#" : ".");
						}
						std::cout << std::endl;
					}
					std::cout << "Expected to evaluate to: " << (expectedState ? "#" : ".") << std::endl;
					std::cout << "Actual value: " << (actualState ? "#" : ".") << std::endl;
				}

				ASSERT_EQ(expectedState, actualState);
			}
		}

		/// Evaluates state of lookup table based on coordinates and key (state).
		static size_t getLookupTableCellState(size_t x, size_t y, size_t key) {
			size_t index = y * 6 + x;
			return (key >> ((3 * 6 - 1) - index)) & 0x1u;
		}

		/// Returns number of set bits in first 9 bits representing 3x3 life world.
		static size_t countSetBits(size_t value) {
			// Counting bits set in 14-bit words using 64-bit instructions.
			// http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSet64
			return (value * 0x200040008001ULL & 0x111111111111111ULL) % 0xf;
		}

		/// Determines if a middle cell from 3x3 patch is alive.
		static bool isMiddleAlive(size_t patch3x3) {
			size_t aliveCount = countSetBits(patch3x3);
			aliveCount -= (patch3x3 & 0x10) ? 1 : 0;
			return aliveCount == 3 || (aliveCount == 2 && (patch3x3 & 0x10) != 0);
		}

	};

	typedef TLifeTests<> LifeTests;
}
